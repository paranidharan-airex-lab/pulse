{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PULSE: Python Unified Library for Sensor Emulation","text":"<p>Welcome to the documentation for PULSE, a comprehensive Python library for synthetic sensor data generation. This documentation will guide you through installation, usage, and development of the PULSE library.</p>"},{"location":"#what-is-pulse","title":"What is PULSE?","text":"<p>PULSE is a sophisticated Python library jointly developed by Zenteiq Aitech Innovations Private Limited and the AiREX Lab at Indian Institute of Science, Bangalore. It provides a unified interface for simulating realistic datasets from various sensors and radars across multiple domains.</p>"},{"location":"#core-capabilities","title":"Core Capabilities","text":"<p>PULSE enables you to:</p> <ul> <li>Generate synthetic sensor data for testing and validation</li> <li>Simulate complex radar-sensor interactions</li> <li>Create realistic time-series data with configurable parameters</li> <li>Inject and model various types of errors and anomalies</li> <li>Integrate with existing data pipelines and ML workflows</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#comprehensive-sensor-coverage","title":"Comprehensive Sensor Coverage","text":"<ul> <li>Support for multiple sensor types across various domains</li> <li>Extensible architecture for adding new sensor types</li> <li>Domain-specific parameter configurations</li> </ul>"},{"location":"#advanced-simulation-capabilities","title":"Advanced Simulation Capabilities","text":"<ul> <li>PDW (Pulse Descriptor Word) simulation</li> <li>Configurable noise levels and error models</li> <li>Time-series generation with adjustable parameters</li> <li>Synthetic anomaly injection</li> <li>High-performance computing optimization using JAX and NumPy</li> </ul>"},{"location":"#flexible-integration","title":"Flexible Integration","text":"<ul> <li>Simple Python API</li> <li>Streamlit-based user interface</li> <li>Support for various data formats including HDF5</li> <li>Compatible with major data science tools and frameworks</li> </ul>"},{"location":"#project-structure","title":"Project Structure","text":"<p>The PULSE library is organized into several key components:</p> <pre><code>pulse_pdw/\n\u251c\u2500\u2500 src/pulse/           # Core library code\n\u251c\u2500\u2500 tests/              # Test suite\n\u251c\u2500\u2500 apps/               # Web interface\n\u251c\u2500\u2500 docs/              # Documentation\n\u2514\u2500\u2500 examples/          # Usage examples\n</code></pre>"},{"location":"#current-implementation","title":"Current Implementation","text":"<p>The current version focuses on the PDW (Pulse Descriptor Word) Simulator, which provides:</p> <ul> <li>Scenario Management</li> <li>Radar Properties Configuration</li> <li>Sensor Properties Modeling</li> <li>Geometric Calculations</li> <li>Error Modeling</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with PULSE:</p> <ol> <li>Check the Installation Guide for setup instructions</li> <li>Review the Testing Guide for validation procedures</li> <li>Explore the examples directory for usage demonstrations</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community! Please see our Contributing Guidelines for details on:</p> <ul> <li>Development workflow</li> <li>Code standards</li> <li>Pull request process</li> <li>Testing requirements</li> </ul>"},{"location":"#support-and-contact","title":"Support and Contact","text":"<p>For support:</p> <ul> <li>Create an issue on GitHub: https://github.com/zenoxml/pulse/issues</li> <li>Email: contact@scirex.org</li> </ul>"},{"location":"#license","title":"License","text":"<p>PULSE is licensed under the Apache License 2.0. See the LICENSE file for details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use PULSE in your research, please cite:</p> <pre><code>@software{pulse2025,\n  title = {PULSE: Python Unified Library for Sensor Emulation},\n  author = {{Zenteiq Aitech Innovations} and {AiREX Lab}},\n  year = {2025},\n  url = {https://github.com/zenoxml/pulse}\n}\n</code></pre>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This project is developed in collaboration with:</p> <ul> <li>Zenteiq Aitech Innovations Private Limited</li> <li>AiREX Lab at Indian Institute of Science, Bangalore</li> <li>ARTPARK (AI &amp; Robotics Technology Park) at IISc</li> </ul>"},{"location":"installation_guide/","title":"Installation Guide","text":"<p>This guide provides detailed instructions for installing and setting up the PULSE library. We'll cover both basic installation and development setup options.</p>"},{"location":"installation_guide/#prerequisites","title":"Prerequisites","text":"<p>Before installing PULSE, ensure you have:</p> <ul> <li>Python 3.12 or higher</li> <li>pip or conda package manager</li> <li>Git (for development installation)</li> </ul>"},{"location":"installation_guide/#installation-methods","title":"Installation Methods","text":""},{"location":"installation_guide/#method-1-using-conda-recommended-for-development","title":"Method 1: Using Conda (Recommended for Development)","text":"<ol> <li> <p>Create a new conda environment: <pre><code>conda create -n pulse_env python=3.12\nconda activate pulse_env\n</code></pre></p> </li> <li> <p>Install core dependencies: <pre><code>conda install numpy scipy pandas streamlit pyyaml h5py plotly\nconda install -c conda-forge pint\n</code></pre></p> </li> <li> <p>Install PULSE in development mode: <pre><code>git clone https://github.com/zenoxml/pulse.git\ncd pulse\npip install -e .\n</code></pre></p> </li> </ol>"},{"location":"installation_guide/#method-2-using-pip-for-users","title":"Method 2: Using pip (For Users)","text":"<pre><code>pip install pulse-pdw\n</code></pre>"},{"location":"installation_guide/#verifying-installation","title":"Verifying Installation","text":"<p>To verify your installation:</p> <ol> <li> <p>Start Python: <pre><code>python\n</code></pre></p> </li> <li> <p>Try importing PULSE: <pre><code>import pulse\nprint(pulse.__version__)\n</code></pre></p> </li> </ol>"},{"location":"installation_guide/#configuration-setup","title":"Configuration Setup","text":""},{"location":"installation_guide/#basic-configuration","title":"Basic Configuration","text":"<ol> <li> <p>Create a configuration directory: <pre><code>mkdir ~/.pulse\n</code></pre></p> </li> <li> <p>Create a basic configuration file (<code>config.yaml</code>): <pre><code>scenario:\n  start_time: 0\n  end_time: 10\n  time_step: 0.1\n\nradars:\n  - name: \"Radar1\"\n    start_position: [0, 0]\n    rotation_type: \"constant\"\n    rotation_params:\n      t0: 0\n      alpha0: 0\n      T_rot: 4\n    pri_type: \"fixed\"\n    pri_params:\n      pri: 0.001\n\nsensors:\n  - name: \"Sensor1\"\n    start_position: [1000, 1000]\n    error_model: \"gaussian\"\n    error_params:\n      mean: 0\n      std: 0.1\n</code></pre></p> </li> </ol>"},{"location":"installation_guide/#advanced-configuration","title":"Advanced Configuration","text":"<p>For advanced users, PULSE supports additional configuration options:</p> <ul> <li>Custom error models</li> <li>Specialized sensor configurations</li> <li>Performance optimization settings</li> <li>Output format specifications</li> </ul> <p>Create these configurations in separate YAML files within your project directory.</p>"},{"location":"installation_guide/#running-the-web-interface","title":"Running the Web Interface","text":"<p>To launch the Streamlit-based user interface:</p> <pre><code>streamlit run apps/app.py\n</code></pre>"},{"location":"installation_guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation_guide/#common-issues","title":"Common Issues","text":"<ol> <li>Dependency Conflicts</li> <li>Solution: Use a fresh conda environment</li> <li> <p>Alternative: Check <code>requirements.txt</code> for specific versions</p> </li> <li> <p>Import Errors</p> </li> <li>Verify Python path settings</li> <li>Check installation location</li> <li> <p>Confirm all dependencies are installed</p> </li> <li> <p>Configuration Issues</p> </li> <li>Validate YAML syntax</li> <li>Check file permissions</li> <li>Verify file locations</li> </ol>"},{"location":"installation_guide/#getting-help","title":"Getting Help","text":"<p>If you encounter problems:</p> <ol> <li>Check the GitHub Issues</li> <li>Review error messages and logs</li> <li>Contact support at contact@scirex.org</li> </ol>"},{"location":"installation_guide/#next-steps","title":"Next Steps","text":"<p>After installation:</p> <ol> <li>Review the Testing Guide</li> <li>Explore example scripts in the <code>examples/</code> directory</li> <li>Read the API documentation</li> </ol>"},{"location":"installation_guide/#system-requirements","title":"System Requirements","text":""},{"location":"installation_guide/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Python 3.12+</li> <li>4GB RAM</li> <li>1GB disk space</li> </ul>"},{"location":"testing/","title":"Testing Guide","text":"<p>This guide provides comprehensive information about testing the PULSE library, including unit tests, integration tests, and validation procedures.</p>"},{"location":"testing/#testing-overview","title":"Testing Overview","text":"<p>PULSE uses pytest as its primary testing framework and includes several types of tests:</p> <ul> <li>Unit tests for individual components</li> <li>Integration tests for system-wide functionality</li> <li>Performance tests for optimization</li> <li>Validation tests for accuracy</li> </ul>"},{"location":"testing/#running-tests","title":"Running Tests","text":""},{"location":"testing/#basic-test-execution","title":"Basic Test Execution","text":"<p>To run the complete test suite:</p> <pre><code>pytest tests/\n</code></pre> <p>For specific test categories:</p> <pre><code># Run only unit tests\npytest tests/test_models.py\n\n# Run integration tests\npytest tests/test_integration.py\n\n# Run with verbose output\npytest -v tests/\n</code></pre>"},{"location":"testing/#test-configuration","title":"Test Configuration","text":""},{"location":"testing/#using-test-fixtures","title":"Using test fixtures","text":"<p>Tests use fixtures defined in <code>tests/conftest.py</code>:</p> <pre><code>@pytest.fixture\ndef basic_scenario():\n    return {\n        'start_time': 0,\n        'end_time': 10,\n        'time_step': 0.1\n    }\n\n@pytest.fixture\ndef basic_radar():\n    return {\n        'name': 'TestRadar',\n        'position': [0, 0],\n        'rotation_type': 'constant'\n    }\n</code></pre>"},{"location":"testing/#custom-test-configurations","title":"Custom test configurations","text":"<p>Create custom test configurations in <code>tests/fixtures/test_config.yaml</code>:</p> <pre><code>test_scenario:\n  duration: 100\n  sample_rate: 1000\n\ntest_parameters:\n  noise_level: 0.1\n  error_threshold: 0.01\n</code></pre>"},{"location":"testing/#test-categories","title":"Test Categories","text":""},{"location":"testing/#1-unit-tests","title":"1. Unit Tests","text":"<p>Unit tests cover individual components:</p> <ul> <li>Core classes (Scenario, Radar, Sensor)</li> <li>Utility functions</li> <li>Error models</li> <li>Data generators</li> </ul>"},{"location":"testing/#2-integration-tests","title":"2. Integration Tests","text":"<p>Integration tests verify system-wide functionality:</p> <ul> <li>End-to-end simulation workflows</li> <li>Data pipeline integration</li> <li>Configuration management</li> <li>Error handling</li> </ul>"},{"location":"testing/#3-performance-tests","title":"3. Performance Tests","text":"<p>Performance tests evaluate:</p> <ul> <li>Computation speed</li> <li>Memory usage</li> <li>Scalability</li> <li>Resource optimization</li> </ul>"},{"location":"testing/#4-validation-tests","title":"4. Validation Tests","text":"<p>Validation tests ensure:</p> <ul> <li>Physical accuracy of simulations</li> <li>Statistical validity of generated data</li> <li>Proper error modeling</li> <li>Configuration handling</li> </ul>"},{"location":"testing/#writing-tests","title":"Writing Tests","text":""},{"location":"testing/#test-structure","title":"Test Structure","text":"<p>Follow this structure for new tests:</p> <pre><code>def test_component_function():\n    # Setup\n    input_data = prepare_test_data()\n\n    # Exercise\n    result = component_function(input_data)\n\n    # Verify\n    assert result.property == expected_value\n    assert validate_output(result)\n\n    # Cleanup (if needed)\n    cleanup_test_data()\n</code></pre>"},{"location":"testing/#test-guidelines","title":"Test Guidelines","text":"<ol> <li>Isolation: Each test should be independent</li> <li>Clarity: Use descriptive test names</li> <li>Coverage: Aim for comprehensive coverage</li> <li>Performance: Keep tests efficient</li> <li>Maintenance: Keep tests up to date</li> </ol>"},{"location":"testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"testing/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<p>Tests are automatically run on:</p> <ul> <li>Pull requests</li> <li>Main branch commits</li> <li>Release tags</li> </ul>"},{"location":"testing/#ci-configuration","title":"CI Configuration","text":"<pre><code>name: PULSE Tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.12'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Run tests\n        run: |\n          pytest tests/\n</code></pre>"},{"location":"testing/#test-coverage","title":"Test Coverage","text":""},{"location":"testing/#generating-coverage-reports","title":"Generating Coverage Reports","text":"<pre><code>pytest --cov=pulse tests/\n</code></pre>"},{"location":"testing/#coverage-requirements","title":"Coverage Requirements","text":"<ul> <li>Minimum coverage: 80%</li> <li>Critical components: 95%</li> <li>New features: 100%</li> </ul>"},{"location":"testing/#troubleshooting-tests","title":"Troubleshooting Tests","text":""},{"location":"testing/#common-issues","title":"Common Issues","text":"<ol> <li>Failed Tests</li> <li>Check test dependencies</li> <li>Verify test data</li> <li> <p>Review error messages</p> </li> <li> <p>Slow Tests</p> </li> <li>Profile test execution</li> <li>Optimize test data</li> <li> <p>Review test isolation</p> </li> <li> <p>Flaky Tests</p> </li> <li>Check for race conditions</li> <li>Verify test independence</li> <li>Review timing assumptions</li> </ol>"},{"location":"testing/#best-practices","title":"Best Practices","text":"<ol> <li>Test Data Management</li> <li>Use fixtures for common data</li> <li>Clean up test artifacts</li> <li> <p>Version control test data</p> </li> <li> <p>Test Organization</p> </li> <li>Group related tests</li> <li>Use meaningful names</li> <li> <p>Document test purposes</p> </li> <li> <p>Test Maintenance</p> </li> <li>Regular updates</li> <li>Remove obsolete tests</li> <li>Keep documentation current</li> </ol>"},{"location":"testing/#contributing-tests","title":"Contributing Tests","text":"<p>When contributing new tests:</p> <ol> <li>Follow existing patterns</li> <li>Include documentation</li> <li>Verify coverage</li> <li>Test edge cases</li> <li>Review performance impact</li> </ol>"},{"location":"api/data_export/","title":"Data Exporter","text":""},{"location":"api/data_export/#src.pdw_simulator.data_export","title":"<code>src.pdw_simulator.data_export</code>","text":""},{"location":"api/data_export/#src.pdw_simulator.data_export.PDWDataExporter","title":"<code>PDWDataExporter</code>","text":"Source code in <code>src\\pdw_simulator\\data_export.py</code> <pre><code>class PDWDataExporter:\n    def __init__(self, size_threshold_mb=100):\n        \"\"\"\n        Initialize PDW Data Exporter\n\n        Args:\n            size_threshold_mb (int): Size threshold in MB to switch from CSV to HDF5\n        \"\"\"\n        self.size_threshold_mb = size_threshold_mb\n        self.metadata = {\n            'time_unix': int(datetime.now().timestamp()),\n            'time_py': str(datetime.now()),\n            'samp_rate': None,\n            'ref_level': None\n        }\n\n    def estimate_data_size(self, pdw_data: pd.DataFrame) -&gt; float:\n        \"\"\"Estimate the size of the data in MB\"\"\"\n        return pdw_data.memory_usage(deep=True).sum() / (1024 * 1024)\n\n    def export_to_csv(self, pdw_data: pd.DataFrame, filename: str):\n        \"\"\"Export data to CSV format\"\"\"\n        pdw_data.to_csv(filename, index=False)\n        # Save metadata separately\n        metadata_file = filename.replace('.csv', '_metadata.csv')\n        pd.DataFrame([self.metadata]).to_csv(metadata_file, index=False)\n\n    def export_to_hdf5(self, pdw_data: pd.DataFrame, filename: str):\n        \"\"\"Export data to HDF5 format with compression\"\"\"\n        with h5py.File(filename, 'w') as f:\n            # Create metadata group\n            meta_group = f.create_group('metadata')\n            for key, value in self.metadata.items():\n                meta_group.attrs[key] = value\n\n            # Create data group with datasets for each column\n            data_group = f.create_group('data')\n            for column in pdw_data.columns:\n                # Create compressed dataset for each column\n                data_group.create_dataset(\n                    column,\n                    data=pdw_data[column].values,\n                    compression='gzip',\n                    compression_opts=9  # Maximum compression\n                )\n\n    def export_data(self, pdw_data: pd.DataFrame, base_filename: str):\n        \"\"\"\n        Export PDW data to appropriate format based on size\n\n        Args:\n            pdw_data: DataFrame containing PDW data\n            base_filename: Base filename without extension\n        \"\"\"\n        estimated_size = self.estimate_data_size(pdw_data)\n\n        if estimated_size &lt; self.size_threshold_mb:\n            # Use CSV for smaller datasets\n            filename = f\"{base_filename}.csv\"\n            self.export_to_csv(pdw_data, filename)\n            return filename\n        else:\n            # Use HDF5 for larger datasets\n            filename = f\"{base_filename}.h5\"\n            self.export_to_hdf5(pdw_data, filename)\n            return filename\n\n    def read_data(self, filename: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Read PDW data from either CSV or HDF5 format\n\n        Args:\n            filename: Path to the data file\n        Returns:\n            DataFrame containing PDW data\n        \"\"\"\n        if filename.endswith('.csv'):\n            return pd.read_csv(filename)\n        elif filename.endswith('.h5'):\n            with h5py.File(filename, 'r') as f:\n                # Read data from HDF5 file\n                data_dict = {}\n                for column in f['data'].keys():\n                    data_dict[column] = f['data'][column][:]\n                return pd.DataFrame(data_dict)\n        else:\n            raise ValueError(\"Unsupported file format\")\n\n    def set_metadata(self, sample_rate: float = None, ref_level: float = None):\n        \"\"\"Set metadata for the export\"\"\"\n        if sample_rate is not None:\n            self.metadata['samp_rate'] = sample_rate\n        if ref_level is not None:\n            self.metadata['ref_level'] = ref_level\n</code></pre>"},{"location":"api/data_export/#src.pdw_simulator.data_export.PDWDataExporter.__init__","title":"<code>__init__(size_threshold_mb=100)</code>","text":"<p>Initialize PDW Data Exporter</p> <p>Parameters:</p> Name Type Description Default <code>size_threshold_mb</code> <code>int</code> <p>Size threshold in MB to switch from CSV to HDF5</p> <code>100</code> Source code in <code>src\\pdw_simulator\\data_export.py</code> <pre><code>def __init__(self, size_threshold_mb=100):\n    \"\"\"\n    Initialize PDW Data Exporter\n\n    Args:\n        size_threshold_mb (int): Size threshold in MB to switch from CSV to HDF5\n    \"\"\"\n    self.size_threshold_mb = size_threshold_mb\n    self.metadata = {\n        'time_unix': int(datetime.now().timestamp()),\n        'time_py': str(datetime.now()),\n        'samp_rate': None,\n        'ref_level': None\n    }\n</code></pre>"},{"location":"api/data_export/#src.pdw_simulator.data_export.PDWDataExporter.estimate_data_size","title":"<code>estimate_data_size(pdw_data)</code>","text":"<p>Estimate the size of the data in MB</p> Source code in <code>src\\pdw_simulator\\data_export.py</code> <pre><code>def estimate_data_size(self, pdw_data: pd.DataFrame) -&gt; float:\n    \"\"\"Estimate the size of the data in MB\"\"\"\n    return pdw_data.memory_usage(deep=True).sum() / (1024 * 1024)\n</code></pre>"},{"location":"api/data_export/#src.pdw_simulator.data_export.PDWDataExporter.export_data","title":"<code>export_data(pdw_data, base_filename)</code>","text":"<p>Export PDW data to appropriate format based on size</p> <p>Parameters:</p> Name Type Description Default <code>pdw_data</code> <code>DataFrame</code> <p>DataFrame containing PDW data</p> required <code>base_filename</code> <code>str</code> <p>Base filename without extension</p> required Source code in <code>src\\pdw_simulator\\data_export.py</code> <pre><code>def export_data(self, pdw_data: pd.DataFrame, base_filename: str):\n    \"\"\"\n    Export PDW data to appropriate format based on size\n\n    Args:\n        pdw_data: DataFrame containing PDW data\n        base_filename: Base filename without extension\n    \"\"\"\n    estimated_size = self.estimate_data_size(pdw_data)\n\n    if estimated_size &lt; self.size_threshold_mb:\n        # Use CSV for smaller datasets\n        filename = f\"{base_filename}.csv\"\n        self.export_to_csv(pdw_data, filename)\n        return filename\n    else:\n        # Use HDF5 for larger datasets\n        filename = f\"{base_filename}.h5\"\n        self.export_to_hdf5(pdw_data, filename)\n        return filename\n</code></pre>"},{"location":"api/data_export/#src.pdw_simulator.data_export.PDWDataExporter.export_to_csv","title":"<code>export_to_csv(pdw_data, filename)</code>","text":"<p>Export data to CSV format</p> Source code in <code>src\\pdw_simulator\\data_export.py</code> <pre><code>def export_to_csv(self, pdw_data: pd.DataFrame, filename: str):\n    \"\"\"Export data to CSV format\"\"\"\n    pdw_data.to_csv(filename, index=False)\n    # Save metadata separately\n    metadata_file = filename.replace('.csv', '_metadata.csv')\n    pd.DataFrame([self.metadata]).to_csv(metadata_file, index=False)\n</code></pre>"},{"location":"api/data_export/#src.pdw_simulator.data_export.PDWDataExporter.export_to_hdf5","title":"<code>export_to_hdf5(pdw_data, filename)</code>","text":"<p>Export data to HDF5 format with compression</p> Source code in <code>src\\pdw_simulator\\data_export.py</code> <pre><code>def export_to_hdf5(self, pdw_data: pd.DataFrame, filename: str):\n    \"\"\"Export data to HDF5 format with compression\"\"\"\n    with h5py.File(filename, 'w') as f:\n        # Create metadata group\n        meta_group = f.create_group('metadata')\n        for key, value in self.metadata.items():\n            meta_group.attrs[key] = value\n\n        # Create data group with datasets for each column\n        data_group = f.create_group('data')\n        for column in pdw_data.columns:\n            # Create compressed dataset for each column\n            data_group.create_dataset(\n                column,\n                data=pdw_data[column].values,\n                compression='gzip',\n                compression_opts=9  # Maximum compression\n            )\n</code></pre>"},{"location":"api/data_export/#src.pdw_simulator.data_export.PDWDataExporter.read_data","title":"<code>read_data(filename)</code>","text":"<p>Read PDW data from either CSV or HDF5 format</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the data file</p> required <p>Returns:     DataFrame containing PDW data</p> Source code in <code>src\\pdw_simulator\\data_export.py</code> <pre><code>def read_data(self, filename: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Read PDW data from either CSV or HDF5 format\n\n    Args:\n        filename: Path to the data file\n    Returns:\n        DataFrame containing PDW data\n    \"\"\"\n    if filename.endswith('.csv'):\n        return pd.read_csv(filename)\n    elif filename.endswith('.h5'):\n        with h5py.File(filename, 'r') as f:\n            # Read data from HDF5 file\n            data_dict = {}\n            for column in f['data'].keys():\n                data_dict[column] = f['data'][column][:]\n            return pd.DataFrame(data_dict)\n    else:\n        raise ValueError(\"Unsupported file format\")\n</code></pre>"},{"location":"api/data_export/#src.pdw_simulator.data_export.PDWDataExporter.set_metadata","title":"<code>set_metadata(sample_rate=None, ref_level=None)</code>","text":"<p>Set metadata for the export</p> Source code in <code>src\\pdw_simulator\\data_export.py</code> <pre><code>def set_metadata(self, sample_rate: float = None, ref_level: float = None):\n    \"\"\"Set metadata for the export\"\"\"\n    if sample_rate is not None:\n        self.metadata['samp_rate'] = sample_rate\n    if ref_level is not None:\n        self.metadata['ref_level'] = ref_level\n</code></pre>"},{"location":"api/decorators/","title":"Decorators","text":""},{"location":"api/decorators/#src.pdw_simulator.decorators","title":"<code>src.pdw_simulator.decorators</code>","text":""},{"location":"api/decorators/#src.pdw_simulator.decorators.say_hello","title":"<code>say_hello()</code>","text":"<p>I dont think this will get printed</p> Source code in <code>src\\pdw_simulator\\decorators.py</code> <pre><code>@my_decorator\ndef say_hello():\n    \"\"\"I dont think this will get printed\"\"\"\n    print('Hello!')\n</code></pre>"},{"location":"api/hardware_opt/","title":"Hardware opt","text":""},{"location":"api/hardware_opt/#src.pdw_simulator.hardware_opt","title":"<code>src.pdw_simulator.hardware_opt</code>","text":""},{"location":"api/hardware_opt/#src.pdw_simulator.hardware_opt.HardwareManager","title":"<code>HardwareManager</code>","text":"Source code in <code>src\\pdw_simulator\\hardware_opt.py</code> <pre><code>class HardwareManager:\n    def __init__(self):\n        self.has_cuda = False\n        self.device = None\n        self._check_cuda()\n\n    def _check_cuda(self):\n        \"\"\"Check if CUDA is available\"\"\"\n        try:\n            cuda.detect()\n            self.has_cuda = cuda.is_available()\n            if self.has_cuda:\n                self.device = cuda.get_current_device()\n                print(f\"CUDA Device found:{self.device.name}\")\n        except Exception as e:\n            warnings.warn(f\"CUDA Not able to detect:{str(e)}\")\n            self.has_cuda = False\n\n    def get_optimal_batch_size(self):\n        \"\"\"Get Optimal Batch size based on current hardware \"\"\"\n        if self.has_cuda:\n            return min(self.device.MAX_THREADS_PER_BLOCK, 1024)\n        else:\n            return 128\n</code></pre>"},{"location":"api/hardware_opt/#src.pdw_simulator.hardware_opt.HardwareManager.get_optimal_batch_size","title":"<code>get_optimal_batch_size()</code>","text":"<p>Get Optimal Batch size based on current hardware</p> Source code in <code>src\\pdw_simulator\\hardware_opt.py</code> <pre><code>def get_optimal_batch_size(self):\n    \"\"\"Get Optimal Batch size based on current hardware \"\"\"\n    if self.has_cuda:\n        return min(self.device.MAX_THREADS_PER_BLOCK, 1024)\n    else:\n        return 128\n</code></pre>"},{"location":"api/hardware_opt/#src.pdw_simulator.hardware_opt.numba_optimize","title":"<code>numba_optimize(parallel=True)</code>","text":"<p>Simplified decorator that uses Numba's CPU optimization</p> Source code in <code>src\\pdw_simulator\\hardware_opt.py</code> <pre><code>def numba_optimize(parallel=True):\n    \"\"\"Simplified decorator that uses Numba's CPU optimization\"\"\"\n    def decorator(f):\n        optimized_f = jit(nopython=True, parallel=parallel)(f)\n        return optimized_f\n    return decorator\n</code></pre>"},{"location":"api/main/","title":"Main","text":""},{"location":"api/main/#src.pdw_simulator.main","title":"<code>src.pdw_simulator.main</code>","text":""},{"location":"api/main/#src.pdw_simulator.main.run_simulation","title":"<code>run_simulation(scenario, output_base_filename)</code>","text":"<p>Run the PDW simulation with adaptive file format selection.</p> <p>:param scenario: Scenario object containing radars and sensors :param output_base_filename: Base filename without extension for output</p> Source code in <code>src\\pdw_simulator\\main.py</code> <pre><code>def run_simulation(scenario, output_base_filename):\n    \"\"\"\n    Run the PDW simulation with adaptive file format selection.\n\n    :param scenario: Scenario object containing radars and sensors\n    :param output_base_filename: Base filename without extension for output\n    \"\"\"\n    # Create lists to store all the data\n    times = []\n    sensor_ids = []\n    radar_ids = []\n    toas = []\n    amplitudes = []\n    frequencies = []\n    pulse_widths = []\n    aoas = []\n\n    while scenario.current_time &lt;= scenario.end_time:\n        scenario.update()\n\n        for sensor in scenario.sensors:\n            for radar in scenario.radars:\n                pdw = generate_pdw(sensor, radar, scenario.current_time)\n                if pdw:\n                    times.append(scenario.current_time.magnitude)\n                    sensor_ids.append(sensor.name)\n                    radar_ids.append(radar.name)\n                    toas.append(pdw['TOA'].magnitude)\n                    amplitudes.append(pdw['Amplitude'].magnitude)\n                    frequencies.append(pdw['Frequency'].magnitude)\n                    pulse_widths.append(pdw['PulseWidth'].magnitude)\n                    aoas.append(pdw['AOA'].magnitude)\n\n        scenario.current_time += scenario.time_step\n\n    # Create DataFrame from collected data\n    pdw_data = pd.DataFrame({\n        'Time': times,\n        'SensorID': sensor_ids,\n        'RadarID': radar_ids,\n        'TOA': toas,\n        'Amplitude': amplitudes,\n        'Frequency': frequencies,\n        'PulseWidth': pulse_widths,\n        'AOA': aoas\n    })\n\n    # Initialize exporter with 100MB threshold\n    exporter = PDWDataExporter(size_threshold_mb=100)\n\n    # Set metadata if available\n    exporter.set_metadata(\n        sample_rate=1/scenario.time_step.magnitude,  # Convert time step to sample rate\n        ref_level=None  # Add reference level if available in your scenario\n    )\n\n    # Export data\n    output_file = exporter.export_data(pdw_data, output_base_filename)\n\n    return output_file\n</code></pre>"},{"location":"api/model/","title":"Model","text":""},{"location":"api/model/#src.pdw_simulator.models","title":"<code>src.pdw_simulator.models</code>","text":""},{"location":"api/model/#src.pdw_simulator.models.Radar","title":"<code>Radar</code>","text":"Source code in <code>src\\pdw_simulator\\models.py</code> <pre><code>class Radar:\n    def __init__(self, config):\n        self.name = config['name']\n        self.start_position = np.array(config['start_position']) * ureg.meter\n        self.velocity = np.array(config.get('velocity', [0, 0])) * ureg('meter/second')\n        self.start_time = config.get('start_time', 0) * ureg.second\n        self.current_time = self.start_time\n\n        # Rotation period parameters\n        self.rotation_type = config['rotation_type']\n        self.rotation_params = config['rotation_params']\n        self.rotation_data = None\n        self.current_angle = self.rotation_params['alpha0']\n        self.current_period = self.rotation_params['T_rot'] * ureg.second\n        # self.frequency = config['frequency'] * ureg.hertz\n        # self.pulse_width = config['pulse_width'] * ureg.second\n        self.power = config['power'] * ureg.watt\n        self.trajectory = None\n        self.current_position = self.start_position\n\n        ## PRI \n        self.pri_type=config['pri_type']\n        self.pri_params=config['pri_params']\n        self.pulse_times=None\n\n\n        ## Frequency \n        self.frequency_type = config['frequency_type']\n        self.frequency_params = config['frequency_params']\n        self.pulse_width_type = config['pulse_width_type']\n        self.pulse_width_params = config['pulse_width_params']\n        self.frequencies = None\n        self.pulse_widths = None\n\n\n        #Antenna Lobe pattern\n        self.lobe_pattern_type = config['lobe_pattern']['type']\n        if self.lobe_pattern_type == 'Sinc':\n            self.theta_ml = config['lobe_pattern']['main_lobe_opening_angle'] * ureg.degree\n            self.P_ml = config['lobe_pattern']['radar_power_at_main_lobe'] * ureg.dB\n            self.P_bl = config['lobe_pattern']['radar_power_at_back_lobe'] * ureg.dB\n\n    def get_next_pulse_time(self, current_time):\n        \"\"\"\n        Get the next pulse time after the current time.\n\n        :param current_time: Current simulation time\n        :return: Next pulse time or None if no more pulses\n        \"\"\"\n        if self.pulse_times is None:\n            return None\n        next_pulse_index = np.searchsorted(self.pulse_times, current_time.magnitude, side='left')\n        if next_pulse_index &lt; len(self.pulse_times):\n            return self.pulse_times[next_pulse_index] * ureg.second\n        return None\n\n    def get_current_frequency(self):\n        \"\"\"\n        Get the current frequency of the radar.\n\n        :return: Current frequency\n        \"\"\"\n        if self.frequencies is None:\n            return None\n        # print(\"Hi Harshwardhan\")\n        # print(type((self.frequencies[0])))\n        # print(self.frequencies[0])\n        true_freq=self.frequencies[0].astype(float)\n        # return self.frequencies[0] * ureg.Hz\n        return true_freq * ureg.Hz\n\n    def get_current_pulse_width(self):\n        \"\"\"\n        Get the current pulse width of the radar.\n\n        :return: Current pulse width\n        \"\"\"\n        # print(type((self.frequencies[0])))\n        # print(self.frequencies[0])\n        if self.pulse_widths is None:\n            return None\n        true_pw=self.pulse_widths[0].astype(float)\n        print(true_pw)\n        return true_pw * ureg.second\n\n    def calculate_power_at_angle(self, theta):\n        if self.lobe_pattern_type == 'Sinc':\n            return sinc_lobe_pattern(theta, self.theta_ml, self.P_ml, self.P_bl)\n        else:\n            raise ValueError(f\"Unsupported lobe pattern type: {self.lobe_pattern_type}\")\n\n    def get_current_angle(self):\n        return self.current_angle * ureg.radian\n\n    def get_current_period(self):\n        return self.current_period\n\n    def calculate_pulse_times(self, end_time):\n        if self.pri_type == 'fixed':\n            self.pulse_times = fixed_pri(self.start_time.magnitude, end_time.magnitude, self.pri_params['pri'])\n        elif self.pri_type == 'stagger':\n            self.pulse_times = stagger_pri(self.start_time.magnitude, end_time.magnitude, self.pri_params['pri_pattern'])\n        elif self.pri_type == 'switched':\n            self.pulse_times = switched_pri(self.start_time.magnitude, end_time.magnitude, \n                                            self.pri_params['pri_pattern'], self.pri_params['repetitions'])\n        elif self.pri_type == 'jitter':\n            self.pulse_times = jitter_pri(self.start_time.magnitude, end_time.magnitude, \n                                          self.pri_params['mean_pri'], self.pri_params['jitter_percentage'])\n        else:\n            raise ValueError(f\"Invalid PRI type: {self.pri_type}\")\n\n    def calculate_frequencies(self, end_time):\n            if self.frequency_type == 'fixed':\n                self.frequencies = fixed_frequency(self.start_time.magnitude, end_time.magnitude, self.frequency_params['frequency'])\n            elif self.frequency_type == 'stagger':\n                self.frequencies = stagger_frequency(self.start_time.magnitude, end_time.magnitude, self.frequency_params['frequency_pattern'])\n            elif self.frequency_type == 'switched':\n                self.frequencies = switched_frequency(self.start_time.magnitude, end_time.magnitude, \n                                                    self.frequency_params['frequency_pattern'], self.frequency_params['repetitions'])\n            elif self.frequency_type == 'jitter':\n                self.frequencies = jitter_frequency(self.start_time.magnitude, end_time.magnitude, \n                                                    self.frequency_params['mean_frequency'], self.frequency_params['jitter_percentage'])\n            else:\n                raise ValueError(f\"Invalid frequency type: {self.frequency_type}\")\n\n    def calculate_pulse_widths(self, end_time):\n        if self.pulse_width_type == 'fixed':\n            self.pulse_widths = fixed_pulse_width(self.start_time.magnitude, end_time.magnitude, self.pulse_width_params['pulse_width'])\n        elif self.pulse_width_type == 'stagger':\n            self.pulse_widths = stagger_pulse_width(self.start_time.magnitude, end_time.magnitude, self.pulse_width_params['pulse_width_pattern'])\n        elif self.pulse_width_type == 'switched':\n            self.pulse_widths = switched_pulse_width(self.start_time.magnitude, end_time.magnitude, \n                                                     self.pulse_width_params['pulse_width_pattern'], self.pulse_width_params['repetitions'])\n        elif self.pulse_width_type == 'jitter':\n            self.pulse_widths = jitter_pulse_width(self.start_time.magnitude, end_time.magnitude, \n                                                   self.pulse_width_params['mean_pulse_width'], self.pulse_width_params['jitter_percentage'])\n        else:\n            raise ValueError(f\"Invalid pulse width type: {self.pulse_width_type}\")\n\n    def calculate_trajectory(self, end_time, time_step):\n        if np.any(self.velocity != 0):\n            self.trajectory = calculate_trajectory(\n                self.start_position.magnitude, end_time.magnitude, time_step.magnitude,\n                self.velocity.magnitude, self.start_time.magnitude)\n        else:\n            self.trajectory = calculate_trajectory(\n                self.start_position.magnitude, end_time.magnitude, time_step.magnitude)\n\n        self.calculate_pulse_times(end_time)\n        print(f\"Initialized {self.name} with {len(self.pulse_times)} pulse times\")\n        self.calculate_frequencies(end_time)\n        self.calculate_pulse_widths(end_time)\n\n        # Calculate rotation angles and periods\n        self.rotation_data = calculate_rotation_angles(\n            self.start_time.magnitude, end_time.magnitude, time_step.magnitude,\n            self.rotation_type, self.rotation_params)\n\n    def update_position(self, current_time):\n        if self.trajectory is not None:\n            idx = np.searchsorted([t[0] for t in self.trajectory], current_time.magnitude)\n            if idx &lt; len(self.trajectory):\n                self.current_position = np.array([self.trajectory[idx][1], self.trajectory[idx][2]]) * ureg.meter\n\n        # Update rotation angle and period\n        if self.rotation_data is not None:\n            idx = np.searchsorted([t[0] for t in self.rotation_data], current_time.magnitude)\n            if idx &lt; len(self.rotation_data):\n                self.current_angle = self.rotation_data[idx][1]\n                self.current_period = self.rotation_data[idx][2] * ureg.second\n\n\n    def get_current_angle(self):\n        if self.rotation_data is not None:\n            idx = np.searchsorted([t[0] for t in self.rotation_data], self.current_time.magnitude)\n            if idx &lt; len(self.rotation_data):\n                return self.rotation_data[idx][1] * ureg.radian\n        return 0 * ureg.radian\n\n    def get_current_period(self):\n        if self.rotation_data is not None:\n            idx = np.searchsorted([t[0] for t in self.rotation_data], self.current_time.magnitude)\n            if idx &lt; len(self.rotation_data):\n                return self.rotation_data[idx][2] * ureg.second\n        return self.rotation_params['T_rot'] * ureg.second\n\n    def update(self, current_time):\n        self.current_time = current_time\n        self.update_position(current_time)\n        self.update_rotation(current_time)\n\n    def update_position(self, current_time):\n        if self.trajectory is not None:\n            idx = np.searchsorted([t[0] for t in self.trajectory], current_time.magnitude)\n            if idx &lt; len(self.trajectory):\n                self.current_position = np.array([self.trajectory[idx][1], self.trajectory[idx][2]]) * ureg.meter\n\n    def update_rotation(self, current_time):\n        if self.rotation_data is not None:\n            idx = np.searchsorted([t[0] for t in self.rotation_data], current_time.magnitude)\n            if idx &lt; len(self.rotation_data):\n                self.current_angle = self.rotation_data[idx][1]\n                self.current_period = self.rotation_data[idx][2] * ureg.second\n\n    def get_current_angle(self):\n        return self.current_angle * ureg.radian\n\n    def get_current_period(self):\n        return self.current_period\n</code></pre>"},{"location":"api/model/#src.pdw_simulator.models.Radar.get_current_frequency","title":"<code>get_current_frequency()</code>","text":"<p>Get the current frequency of the radar.</p> <p>:return: Current frequency</p> Source code in <code>src\\pdw_simulator\\models.py</code> <pre><code>def get_current_frequency(self):\n    \"\"\"\n    Get the current frequency of the radar.\n\n    :return: Current frequency\n    \"\"\"\n    if self.frequencies is None:\n        return None\n    # print(\"Hi Harshwardhan\")\n    # print(type((self.frequencies[0])))\n    # print(self.frequencies[0])\n    true_freq=self.frequencies[0].astype(float)\n    # return self.frequencies[0] * ureg.Hz\n    return true_freq * ureg.Hz\n</code></pre>"},{"location":"api/model/#src.pdw_simulator.models.Radar.get_current_pulse_width","title":"<code>get_current_pulse_width()</code>","text":"<p>Get the current pulse width of the radar.</p> <p>:return: Current pulse width</p> Source code in <code>src\\pdw_simulator\\models.py</code> <pre><code>def get_current_pulse_width(self):\n    \"\"\"\n    Get the current pulse width of the radar.\n\n    :return: Current pulse width\n    \"\"\"\n    # print(type((self.frequencies[0])))\n    # print(self.frequencies[0])\n    if self.pulse_widths is None:\n        return None\n    true_pw=self.pulse_widths[0].astype(float)\n    print(true_pw)\n    return true_pw * ureg.second\n</code></pre>"},{"location":"api/model/#src.pdw_simulator.models.Radar.get_next_pulse_time","title":"<code>get_next_pulse_time(current_time)</code>","text":"<p>Get the next pulse time after the current time.</p> <p>:param current_time: Current simulation time :return: Next pulse time or None if no more pulses</p> Source code in <code>src\\pdw_simulator\\models.py</code> <pre><code>def get_next_pulse_time(self, current_time):\n    \"\"\"\n    Get the next pulse time after the current time.\n\n    :param current_time: Current simulation time\n    :return: Next pulse time or None if no more pulses\n    \"\"\"\n    if self.pulse_times is None:\n        return None\n    next_pulse_index = np.searchsorted(self.pulse_times, current_time.magnitude, side='left')\n    if next_pulse_index &lt; len(self.pulse_times):\n        return self.pulse_times[next_pulse_index] * ureg.second\n    return None\n</code></pre>"},{"location":"api/radar_properties/","title":"Radar Properties","text":""},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties","title":"<code>src.pdw_simulator.radar_properties</code>","text":""},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.apply_doppler_effect","title":"<code>apply_doppler_effect(measured_frequency, radar, sensor)</code>","text":"<p>Apply Doppler effect to measured frequency based on relative motion.</p> <p>Parameters:</p> Name Type Description Default <code>measured_frequency</code> <p>Base measured frequency (with units)</p> required <code>radar</code> <p>Radar object</p> required <code>sensor</code> <p>Sensor object</p> required <p>Returns:</p> Type Description <p>Frequency with Doppler shift applied (with units)</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def apply_doppler_effect(measured_frequency, radar, sensor):\n    \"\"\"\n    Apply Doppler effect to measured frequency based on relative motion.\n\n    Args:\n        measured_frequency: Base measured frequency (with units)\n        radar: Radar object\n        sensor: Sensor object\n\n    Returns:\n        Frequency with Doppler shift applied (with units)\n    \"\"\"\n    # Calculate relative velocity\n    rel_velocity = calculate_relative_velocity(\n        radar.current_position,\n        radar.velocity,\n        sensor.current_position,\n        sensor.velocity\n    )\n\n    # Calculate and apply Doppler shift\n    doppler_shift = calculate_doppler_shift(measured_frequency, rel_velocity)\n    return measured_frequency + doppler_shift\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.calculate_doppler_shift","title":"<code>calculate_doppler_shift(transmitted_frequency, relative_velocity)</code>","text":"<p>Calculate the Doppler shift in frequency based on relative velocity.</p> <p>Parameters:</p> Name Type Description Default <code>transmitted_frequency</code> <p>Original transmitted frequency (with units)</p> required <code>relative_velocity</code> <p>Relative velocity between radar and target (with units)</p> required <p>Returns:</p> Type Description <p>Doppler shift with appropriate units</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def calculate_doppler_shift(transmitted_frequency, relative_velocity):\n    \"\"\"\n    Calculate the Doppler shift in frequency based on relative velocity.\n\n    Args:\n        transmitted_frequency: Original transmitted frequency (with units)\n        relative_velocity: Relative velocity between radar and target (with units)\n\n    Returns:\n        Doppler shift with appropriate units\n    \"\"\"\n    # Convert to base units for calculation\n    f = transmitted_frequency.to(ureg.Hz).magnitude\n    v = relative_velocity.to(ureg.meter / ureg.second).magnitude\n    c = 299792458  # Speed of light in m/s\n\n    doppler_shift = -2 * f * v / c\n    return doppler_shift * ureg.Hz\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.calculate_relative_velocity","title":"<code>calculate_relative_velocity(radar_position, radar_velocity, sensor_position, sensor_velocity)</code>","text":"<p>Calculate the relative velocity between radar and sensor along their line of sight.</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def calculate_relative_velocity(radar_position, radar_velocity, sensor_position, sensor_velocity):\n    \"\"\"\n    Calculate the relative velocity between radar and sensor along their line of sight.\n    \"\"\"\n    # Convert positions and velocities to base units\n    r_pos = np.array([radar_position[0].to(ureg.meter).magnitude, \n                     radar_position[1].to(ureg.meter).magnitude])\n    r_vel = np.array([radar_velocity[0].to(ureg.meter/ureg.second).magnitude, \n                     radar_velocity[1].to(ureg.meter/ureg.second).magnitude])\n    s_pos = np.array([sensor_position[0].to(ureg.meter).magnitude, \n                     sensor_position[1].to(ureg.meter).magnitude])\n    s_vel = np.array([sensor_velocity[0].to(ureg.meter/ureg.second).magnitude, \n                     sensor_velocity[1].to(ureg.meter/ureg.second).magnitude])\n\n    # Calculate unit vector pointing from radar to sensor\n    displacement = s_pos - r_pos\n    distance = np.linalg.norm(displacement)\n    if distance == 0:\n        return 0.0 * ureg.meter / ureg.second\n\n    unit_vector = displacement / distance\n\n    # Calculate relative velocity vector\n    relative_velocity = s_vel - r_vel\n\n    # Project relative velocity onto line of sight\n    radial_velocity = np.dot(relative_velocity, unit_vector)\n\n    return radial_velocity * ureg.meter / ureg.second\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.calculate_rotation_angles","title":"<code>calculate_rotation_angles(start_time, end_time, time_step, rotation_type, params)</code>","text":"<p>Calculate rotation angles and periods over time.</p> <p>:param start_time: Start time of calculation :param end_time: End time of calculation :param time_step: Time step for calculation :param rotation_type: 'constant' or 'varying' :param params: Dictionary of parameters for the rotation calculation :return: List of [time, angle, period] triples</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def calculate_rotation_angles(start_time, end_time, time_step, rotation_type, params):\n    \"\"\"\n    Calculate rotation angles and periods over time.\n\n    :param start_time: Start time of calculation\n    :param end_time: End time of calculation\n    :param time_step: Time step for calculation\n    :param rotation_type: 'constant' or 'varying'\n    :param params: Dictionary of parameters for the rotation calculation\n    :return: List of [time, angle, period] triples\n    \"\"\"\n    times = np.arange(start_time, end_time + time_step, time_step)\n    if rotation_type == 'constant':\n        angles = constant_rotation_period(times, params['t0'], params['alpha0'], params['T_rot'])\n        periods = np.full_like(times, params['T_rot'])\n    elif rotation_type == 'varying':\n        angles = varying_rotation_period(times, params['t0'], params['alpha0'], params['T_rot'], \n                                         params['A'], params['s'], params['phi0'])\n        periods = calculate_varying_period(times, params['T_rot'], params['A'], params['s'], params['phi0'])\n    else:\n        raise ValueError(\"Invalid rotation type. Must be 'constant' or 'varying'.\")\n\n    return list(zip(times, angles, periods))\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.calculate_varying_period","title":"<code>calculate_varying_period(t, T_rot, A, s, phi0)</code>","text":"<p>Calculate the varying rotation period.</p> <p>:param t: Current time :param T_rot: Constant component of rotation period :param A: Amplitude of variation relative to constant component :param s: Angular frequency of variation relative to constant component :param phi0: Start phase of variation :return: Current rotation period</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def calculate_varying_period(t, T_rot, A, s, phi0):\n    \"\"\"\n    Calculate the varying rotation period.\n\n    :param t: Current time\n    :param T_rot: Constant component of rotation period\n    :param A: Amplitude of variation relative to constant component\n    :param s: Angular frequency of variation relative to constant component\n    :param phi0: Start phase of variation\n    :return: Current rotation period\n    \"\"\"\n    omega0 = 2 * np.pi / T_rot\n    return T_rot / (1 + A * np.sin(s * omega0 * t + phi0))\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.constant_rotation_period","title":"<code>constant_rotation_period(t, t0, alpha0, T_rot)</code>","text":"<p>Calculate the angle for constant rotation period.</p> <p>:param t: Current time :param t0: Start time :param alpha0: Initial angle at t0 :param T_rot: Rotation period :return: Current angle</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def constant_rotation_period(t, t0, alpha0, T_rot):\n    \"\"\"\n    Calculate the angle for constant rotation period.\n\n    :param t: Current time\n    :param t0: Start time\n    :param alpha0: Initial angle at t0\n    :param T_rot: Rotation period\n    :return: Current angle\n    \"\"\"\n    return alpha0 + 2 * np.pi * (t - t0) / T_rot\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.fixed_frequency","title":"<code>fixed_frequency(start_time, end_time, frequency)</code>","text":"<p>Generate fixed frequency values.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param frequency: Fixed frequency value (Hz) :return: Array of frequency values</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def fixed_frequency(start_time, end_time, frequency):\n    \"\"\"\n    Generate fixed frequency values.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param frequency: Fixed frequency value (Hz)\n    :return: Array of frequency values\n    \"\"\"\n    return np.full(int((end_time - start_time) / 0.001), frequency)  # Assuming 1ms intervals\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.fixed_pri","title":"<code>fixed_pri(start_time, end_time, pri)</code>","text":"<p>Generate fixed PRI pulses.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param pri: Fixed PRI value (seconds) :return: Array of pulse times</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def fixed_pri(start_time, end_time, pri):\n    \"\"\"\n    Generate fixed PRI pulses.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param pri: Fixed PRI value (seconds)\n    :return: Array of pulse times\n    \"\"\"\n    return np.arange(start_time, end_time, pri)\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.fixed_pulse_width","title":"<code>fixed_pulse_width(start_time, end_time, pulse_width)</code>","text":"<p>Generate fixed pulse width values.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param pulse_width: Fixed pulse width value (seconds) :return: Array of pulse width values</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def fixed_pulse_width(start_time, end_time, pulse_width):\n    \"\"\"\n    Generate fixed pulse width values.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param pulse_width: Fixed pulse width value (seconds)\n    :return: Array of pulse width values\n    \"\"\"\n    return np.full(int((end_time - start_time) / 0.001), pulse_width)  # Assuming 1ms intervals\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.jitter_frequency","title":"<code>jitter_frequency(start_time, end_time, mean_frequency, jitter_percentage)</code>","text":"<p>Generate jitter frequency values.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param mean_frequency: Mean frequency value (Hz) :param jitter_percentage: Jitter as a percentage of mean frequency :return: Array of frequency values</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def jitter_frequency(start_time, end_time, mean_frequency, jitter_percentage):\n    \"\"\"\n    Generate jitter frequency values.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param mean_frequency: Mean frequency value (Hz)\n    :param jitter_percentage: Jitter as a percentage of mean frequency\n    :return: Array of frequency values\n    \"\"\"\n    num_values = int((end_time - start_time) / 0.001)  # Assuming 1ms intervals\n    # print(mean_frequency)\n    # print(jitter_percentage)\n    # print(type(mean_frequency))\n    # print(type(jitter_percentage))\n    mean_frequency=float(mean_frequency)\n    std_dev = mean_frequency * (jitter_percentage / 100)\n    return stats.truncnorm(\n        (0 - mean_frequency) / std_dev,\n        (np.inf - mean_frequency) / std_dev,\n        loc=mean_frequency,\n        scale=std_dev\n    ).rvs(size=num_values)\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.jitter_pri","title":"<code>jitter_pri(start_time, end_time, mean_pri, jitter_percentage)</code>","text":"<p>Generate jitter PRI pulses using numpy's random number generation.</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def jitter_pri(start_time, end_time, mean_pri, jitter_percentage):\n    \"\"\"\n    Generate jitter PRI pulses using numpy's random number generation.\n    \"\"\"\n    pulse_times = []\n    current_time = start_time\n\n    # Calculate standard deviation\n    std_dev = mean_pri * (jitter_percentage / 100)\n\n    while current_time &lt; end_time:\n        pulse_times.append(current_time)\n\n        # Generate random jitter with clipping to ensure positive values\n        jitter = np.random.normal(0, std_dev)\n        jittered_pri = max(mean_pri + jitter, mean_pri * 0.1)  # Ensure PRI doesn't go below 10% of mean\n\n        current_time += jittered_pri\n\n    return np.array(pulse_times)\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.jitter_pulse_width","title":"<code>jitter_pulse_width(start_time, end_time, mean_pulse_width, jitter_percentage)</code>","text":"<p>Generate jitter pulse width values.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param mean_pulse_width: Mean pulse width value (seconds) :param jitter_percentage: Jitter as a percentage of mean pulse width :return: Array of pulse width values</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def jitter_pulse_width(start_time, end_time, mean_pulse_width, jitter_percentage):\n    \"\"\"\n    Generate jitter pulse width values.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param mean_pulse_width: Mean pulse width value (seconds)\n    :param jitter_percentage: Jitter as a percentage of mean pulse width\n    :return: Array of pulse width values\n    \"\"\"\n    num_values = int((end_time - start_time) / 0.001)  # Assuming 1ms intervals\n    std_dev = mean_pulse_width * (jitter_percentage / 100)\n    return stats.truncnorm(\n        (0 - mean_pulse_width) / std_dev,\n        (np.inf - mean_pulse_width) / std_dev,\n        loc=mean_pulse_width,\n        scale=std_dev\n    ).rvs(size=num_values)\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.sinc_lobe_pattern","title":"<code>sinc_lobe_pattern(theta, theta_ml, P_ml, P_bl)</code>","text":"<p>Calculate the radar antenna lobe pattern using a modified sinc function.</p> <p>:param theta: Angle from the antenna boresight (in radians) :param theta_ml: Main lobe opening angle (in radians) :param P_ml: Radar power at main lobe (in dB) :param P_bl: Radar power at back lobe (in dB) :return: Power at the given angle (in dB)</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def sinc_lobe_pattern(theta, theta_ml, P_ml, P_bl):\n    \"\"\"\n    Calculate the radar antenna lobe pattern using a modified sinc function.\n\n    :param theta: Angle from the antenna boresight (in radians)\n    :param theta_ml: Main lobe opening angle (in radians)\n    :param P_ml: Radar power at main lobe (in dB)\n    :param P_bl: Radar power at back lobe (in dB)\n    :return: Power at the given angle (in dB)\n    \"\"\"\n    # Convert inputs to appropriate units\n    theta = theta.to(ureg.radian).magnitude\n    theta_ml = theta_ml.to(ureg.radian).magnitude\n    P_ml = P_ml.to(ureg.dB).magnitude\n    P_bl = P_bl.to(ureg.dB).magnitude\n    # print(f\"theta: {theta}\")\n    # print(f\"theta_ml: {theta_ml}\")\n    # Calculate x\n    # Small value to avoid division by zero\n    x = 0.443 * np.sin(theta) / np.sin(theta_ml / 2)\n    # x = 0.443 * np.sin(theta) / np.sin(theta_ml / 2)\n    # print(f\"x: {x}\")\n    # Calculate P_theta based on the range of theta\n    P_theta = np.zeros_like(theta)\n\n    # For theta in [-pi/2, pi/2]\n    mask1 = np.abs(theta) &lt;= np.pi/2\n    sinc = ma.masked_invalid(np.sin(np.pi * x[mask1]) / (np.pi * x[mask1]))\n    P_theta[mask1] = 20 * ma.log10(ma.abs(sinc)) + P_ml\n\n    # For theta &gt; pi/2\n    mask2 = theta &gt; np.pi/2\n    P_theta[mask2] = 20 * np.log10(np.abs(np.sin(np.pi * x[mask2]) / (np.pi * x[mask2]))) + P_ml + 2/np.pi * P_bl * (theta[mask2] - np.pi/2)\n\n    # For theta &lt; -pi/2\n    mask3 = theta &lt; -np.pi/2\n    P_theta[mask3] = 20 * np.log10(np.abs(np.sin(np.pi * x[mask3]) / (np.pi * x[mask3]))) + P_ml + 2/np.pi * P_bl * (-theta[mask3] - np.pi/2)\n\n    return P_theta * ureg.dB\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.stagger_frequency","title":"<code>stagger_frequency(start_time, end_time, frequency_pattern)</code>","text":"<p>Generate stagger frequency values.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param frequency_pattern: List of frequency values for the stagger pattern (Hz) :return: Array of frequency values</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def stagger_frequency(start_time, end_time, frequency_pattern):\n    \"\"\"\n    Generate stagger frequency values.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param frequency_pattern: List of frequency values for the stagger pattern (Hz)\n    :return: Array of frequency values\n    \"\"\"\n    num_values = int((end_time - start_time) / 0.001)  # Assuming 1ms intervals\n    return np.tile(frequency_pattern, num_values // len(frequency_pattern) + 1)[:num_values]\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.stagger_pri","title":"<code>stagger_pri(start_time, end_time, pri_pattern)</code>","text":"<p>Generate stagger PRI pulses.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param pri_pattern: List of PRI values for the stagger pattern (seconds) :return: Array of pulse times</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def stagger_pri(start_time, end_time, pri_pattern):\n    \"\"\"\n    Generate stagger PRI pulses.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param pri_pattern: List of PRI values for the stagger pattern (seconds)\n    :return: Array of pulse times\n    \"\"\"\n    pulse_times = []\n    current_time = start_time\n    pri_index = 0\n\n    while current_time &lt; end_time:\n        pulse_times.append(current_time)\n        current_time += pri_pattern[pri_index]\n        pri_index = (pri_index + 1) % len(pri_pattern)\n\n    return np.array(pulse_times)\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.stagger_pulse_width","title":"<code>stagger_pulse_width(start_time, end_time, pulse_width_pattern)</code>","text":"<p>Generate stagger pulse width values.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param pulse_width_pattern: List of pulse width values for the stagger pattern (seconds) :return: Array of pulse width values</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def stagger_pulse_width(start_time, end_time, pulse_width_pattern):\n    \"\"\"\n    Generate stagger pulse width values.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param pulse_width_pattern: List of pulse width values for the stagger pattern (seconds)\n    :return: Array of pulse width values\n    \"\"\"\n    num_values = int((end_time - start_time) / 0.001)  # Assuming 1ms intervals\n    return np.tile(pulse_width_pattern, num_values // len(pulse_width_pattern) + 1)[:num_values]\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.switched_frequency","title":"<code>switched_frequency(start_time, end_time, frequency_pattern, repetitions)</code>","text":"<p>Generate switched frequency values.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param frequency_pattern: List of frequency values for the switched pattern (Hz) :param repetitions: List of repetition counts for each frequency value :return: Array of frequency values</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def switched_frequency(start_time, end_time, frequency_pattern, repetitions):\n    \"\"\"\n    Generate switched frequency values.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param frequency_pattern: List of frequency values for the switched pattern (Hz)\n    :param repetitions: List of repetition counts for each frequency value\n    :return: Array of frequency values\n    \"\"\"\n    frequencies = []\n    for freq, rep in zip(frequency_pattern, repetitions):\n        frequencies.extend([freq] * rep)\n    num_values = int((end_time - start_time) / 0.001)  # Assuming 1ms intervals\n    return np.tile(frequencies, num_values // len(frequencies) + 1)[:num_values]\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.switched_pri","title":"<code>switched_pri(start_time, end_time, pri_pattern, repetitions)</code>","text":"<p>Generate switched PRI pulses.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param pri_pattern: List of PRI values for the switched pattern (seconds) :param repetitions: List of repetition counts for each PRI value :return: Array of pulse times</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def switched_pri(start_time, end_time, pri_pattern, repetitions):\n    \"\"\"\n    Generate switched PRI pulses.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param pri_pattern: List of PRI values for the switched pattern (seconds)\n    :param repetitions: List of repetition counts for each PRI value\n    :return: Array of pulse times\n    \"\"\"\n    pulse_times = []\n    current_time = start_time\n\n    while current_time &lt; end_time:\n        for pri, rep in zip(pri_pattern, repetitions):\n            for _ in range(rep):\n                if current_time &gt;= end_time:\n                    break\n                pulse_times.append(current_time)\n                current_time += pri\n\n    return np.array(pulse_times)\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.switched_pulse_width","title":"<code>switched_pulse_width(start_time, end_time, pulse_width_pattern, repetitions)</code>","text":"<p>Generate switched pulse width values.</p> <p>:param start_time: Start time of the simulation (seconds) :param end_time: End time of the simulation (seconds) :param pulse_width_pattern: List of pulse width values for the switched pattern (seconds) :param repetitions: List of repetition counts for each pulse width value :return: Array of pulse width values</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def switched_pulse_width(start_time, end_time, pulse_width_pattern, repetitions):\n    \"\"\"\n    Generate switched pulse width values.\n\n    :param start_time: Start time of the simulation (seconds)\n    :param end_time: End time of the simulation (seconds)\n    :param pulse_width_pattern: List of pulse width values for the switched pattern (seconds)\n    :param repetitions: List of repetition counts for each pulse width value\n    :return: Array of pulse width values\n    \"\"\"\n    pulse_widths = []\n    for pw, rep in zip(pulse_width_pattern, repetitions):\n        pulse_widths.extend([pw] * rep)\n    num_values = int((end_time - start_time) / 0.001)  # Assuming 1ms intervals\n    return np.tile(pulse_widths, num_values // len(pulse_widths) + 1)[:num_values]\n</code></pre>"},{"location":"api/radar_properties/#src.pdw_simulator.radar_properties.varying_rotation_period","title":"<code>varying_rotation_period(t, t0, alpha0, T_rot, A, s, phi0)</code>","text":"<p>Calculate the angle for varying rotation period.</p> <p>:param t: Current time :param t0: Start time :param alpha0: Initial angle at t0 :param T_rot: Constant component of rotation period :param A: Amplitude of variation relative to constant component :param s: Angular frequency of variation relative to constant component :param phi0: Start phase of variation :return: Current angle</p> Source code in <code>src\\pdw_simulator\\radar_properties.py</code> <pre><code>def varying_rotation_period(t, t0, alpha0, T_rot, A, s, phi0):\n    \"\"\"\n    Calculate the angle for varying rotation period.\n\n    :param t: Current time\n    :param t0: Start time\n    :param alpha0: Initial angle at t0\n    :param T_rot: Constant component of rotation period\n    :param A: Amplitude of variation relative to constant component\n    :param s: Angular frequency of variation relative to constant component\n    :param phi0: Start phase of variation\n    :return: Current angle\n    \"\"\"\n    omega0 = 2 * np.pi / T_rot\n    B = (A / s) * (np.cos(s * omega0 * t0 + phi0) - np.cos(phi0))\n    return alpha0 + omega0 * (t - t0) - (A / s) * np.cos(s * omega0 * t + phi0) + B\n</code></pre>"}]}